"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const context_1 = require("../context");
const attribute_1 = require("./attribute");
const domnode_1 = require("./domnode");
const domtokenlist_1 = require("./domtokenlist");
const selector_1 = require("./selector");
var NodeClosed;
(function (NodeClosed) {
    NodeClosed[NodeClosed["Open"] = 0] = "Open";
    NodeClosed[NodeClosed["EndTag"] = 1] = "EndTag";
    NodeClosed[NodeClosed["VoidOmitted"] = 2] = "VoidOmitted";
    NodeClosed[NodeClosed["VoidSelfClosed"] = 3] = "VoidSelfClosed";
    NodeClosed[NodeClosed["ImplicitClosed"] = 4] = "ImplicitClosed";
})(NodeClosed = exports.NodeClosed || (exports.NodeClosed = {}));
const DOCUMENT_NODE_NAME = "#document";
let counter = 0;
function reset() {
    counter = 0;
}
exports.reset = reset;
class HtmlElement extends domnode_1.DOMNode {
    constructor(tagName, parent, closed = NodeClosed.EndTag, meta, location) {
        super(tagName || DOCUMENT_NODE_NAME);
        this.tagName = tagName;
        this.children = [];
        this.parent = parent;
        this.attr = {};
        this.meta = meta;
        this.closed = closed;
        this.voidElement = this.meta ? this.meta.void : false;
        this.location = location;
        this.unique = counter++;
        this.depth = 0;
        if (parent) {
            parent.children.push(this);
            let cur = parent;
            while (cur.parent) {
                this.depth++;
                cur = cur.parent;
            }
        }
    }
    static rootNode(location) {
        return new HtmlElement(undefined, undefined, undefined, undefined, location);
    }
    static fromTokens(startToken, endToken, parent, metaTable) {
        const tagName = startToken.data[2];
        if (!tagName) {
            throw new Error("tagName cannot be empty");
        }
        const meta = metaTable ? metaTable.getMetaFor(tagName) : null;
        const open = startToken.data[1] !== "/";
        const closed = isClosed(endToken, meta);
        const location = context_1.sliceLocation(startToken.location, 1);
        return new HtmlElement(tagName, open ? parent : undefined, closed, meta, location);
    }
    is(tagName) {
        return (this.tagName && tagName === "*") || this.tagName === tagName;
    }
    isRootElement() {
        return this.nodeName === DOCUMENT_NODE_NAME;
    }
    setAttribute(key, value, location) {
        key = key.toLowerCase();
        this.attr[key] = new attribute_1.Attribute(key, value, location);
    }
    hasAttribute(key) {
        key = key.toLowerCase();
        return key in this.attr;
    }
    getAttribute(key) {
        key = key.toLowerCase();
        if (key in this.attr) {
            return this.attr[key];
        }
        else {
            return null;
        }
    }
    getAttributeValue(key) {
        const attr = this.getAttribute(key);
        if (attr) {
            return attr.value !== null ? attr.value.toString() : null;
        }
        else {
            return null;
        }
    }
    append(node) {
        this.children.push(node);
    }
    get classList() {
        return new domtokenlist_1.DOMTokenList(this.getAttributeValue("class"));
    }
    get id() {
        return this.getAttributeValue("id");
    }
    get siblings() {
        return this.parent.children;
    }
    get previousSibling() {
        const i = this.siblings.findIndex(node => node.unique === this.unique);
        return i >= 1 ? this.siblings[i - 1] : null;
    }
    get nextSibling() {
        const i = this.siblings.findIndex(node => node.unique === this.unique);
        return i <= this.siblings.length - 2 ? this.siblings[i + 1] : null;
    }
    getElementsByTagName(tagName) {
        return this.children.reduce((matches, node) => {
            return matches.concat(node.is(tagName) ? [node] : [], node.getElementsByTagName(tagName));
        }, []);
    }
    querySelector(selector) {
        const it = this.querySelectorImpl(selector);
        return it.next().value || null;
    }
    querySelectorAll(selector) {
        const it = this.querySelectorImpl(selector);
        return Array.from(it);
    }
    *querySelectorImpl(selector) {
        const pattern = new selector_1.Selector(selector);
        yield* pattern.match(this);
    }
    visitDepthFirst(callback) {
        function visit(node) {
            node.children.forEach(visit);
            if (!node.isRootElement()) {
                callback(node);
            }
        }
        visit(this);
    }
    someChildren(callback) {
        return this.children.some(visit);
        function visit(node) {
            if (callback(node)) {
                return true;
            }
            else {
                return node.children.some(visit);
            }
        }
    }
    everyChildren(callback) {
        return this.children.every(visit);
        function visit(node) {
            if (!callback(node)) {
                return false;
            }
            return node.children.every(visit);
        }
    }
    find(callback) {
        function visit(node) {
            if (callback(node)) {
                return node;
            }
            for (const child of node.children) {
                const match = child.find(callback);
                if (match) {
                    return match;
                }
            }
            return null;
        }
        return visit(this);
    }
}
exports.HtmlElement = HtmlElement;
function isClosed(endToken, meta) {
    let closed = NodeClosed.Open;
    if (meta && meta.void) {
        closed = NodeClosed.VoidOmitted;
    }
    if (endToken.data[0] === "/>") {
        closed = NodeClosed.VoidSelfClosed;
    }
    return closed;
}
