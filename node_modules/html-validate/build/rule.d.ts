import { Location } from "./context";
import { HtmlElement } from "./dom";
import { AttributeEvent, ConditionalEvent, DoctypeEvent, DOMReadyEvent, Event, TagCloseEvent, TagOpenEvent, WhitespaceEvent } from "./event";
import { Parser } from "./parser";
import { Reporter } from "./reporter";
export interface RuleOptions {
    [key: string]: any;
}
export interface RuleDocumentation {
    description: string;
    url?: string;
}
export declare type RuleConstructor = new (options: RuleOptions) => Rule;
export declare abstract class Rule<T = any> {
    private reporter;
    private parser;
    private enabled;
    private severity;
    private event;
    name: string;
    readonly options: RuleOptions;
    constructor(options: RuleOptions);
    getSeverity(): number;
    setServerity(severity: number): void;
    setEnabled(enabled: boolean): void;
    isEnabled(): boolean;
    report(node: HtmlElement, message: string, location?: Location, context?: T): void;
    private findLocation;
    on(event: "tag:open", callback: (event: TagOpenEvent) => void): void;
    on(event: "tag:close", callback: (event: TagCloseEvent) => void): void;
    on(event: "dom:load", callback: (event: Event) => void): void;
    on(event: "dom:ready", callback: (event: DOMReadyEvent) => void): void;
    on(event: "doctype", callback: (event: DoctypeEvent) => void): void;
    on(event: "attr", callback: (event: AttributeEvent) => void): void;
    on(event: "whitespace", callback: (event: WhitespaceEvent) => void): void;
    on(event: "conditional", callback: (event: ConditionalEvent) => void): void;
    on(event: "*", callback: (event: Event) => void): void;
    init(parser: Parser, reporter: Reporter, severity: number): void;
    abstract setup(): void;
    documentation(context?: T): RuleDocumentation;
}
export declare function ruleDocumentationUrl(filename: string): string;
