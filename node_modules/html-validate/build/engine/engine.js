"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("../config");
const lexer_1 = require("../lexer");
const parser_1 = require("../parser");
const reporter_1 = require("../reporter");
const rule_1 = require("../rule");
class Engine {
    constructor(config, ParserClass) {
        this.report = new reporter_1.Reporter();
        this.config = config;
        this.ParserClass = ParserClass;
        this.availableRules = {};
        for (const plugin of this.config.getPlugins()) {
            for (const [name, rule] of Object.entries(plugin.rules)) {
                this.availableRules[name] = rule;
            }
        }
    }
    lint(sources) {
        for (const source of sources) {
            const parser = new this.ParserClass(this.config);
            const rules = {};
            for (const [ruleId, [severity, options],] of this.config.getRules().entries()) {
                rules[ruleId] = this.loadRule(ruleId, severity, options, parser, this.report);
            }
            parser.on("directive", (_, event) => {
                this.processDirective(event, parser, rules);
            });
            try {
                parser.parseHtml(source);
            }
            catch (e) {
                if (e instanceof lexer_1.InvalidTokenError) {
                    this.reportError(e.message, e.location);
                }
                else {
                    throw e;
                }
            }
        }
        return this.report.save(sources);
    }
    dumpEvents(source) {
        const parser = new parser_1.Parser(this.config);
        const lines = [];
        parser.on("*", (event, data) => {
            lines.push({ event, data });
        });
        source.forEach(src => parser.parseHtml(src));
        return lines;
    }
    dumpTokens(source) {
        const lexer = new lexer_1.Lexer();
        const lines = [];
        for (const src of source) {
            for (const token of lexer.tokenize(src)) {
                const data = token.data ? token.data[0] : null;
                lines.push({
                    token: lexer_1.TokenType[token.type],
                    data,
                    location: `${token.location.filename}:${token.location.line}:${token.location.column}`,
                });
            }
        }
        return lines;
    }
    dumpTree(source) {
        const parser = new parser_1.Parser(this.config);
        const dom = parser.parseHtml(source[0]);
        const lines = [];
        function decoration(node) {
            let output = "";
            if (node.hasAttribute("id")) {
                output += `#${node.id}`;
            }
            if (node.hasAttribute("class")) {
                output += `.${node.classList.join(".")}`;
            }
            return output;
        }
        function writeNode(node, level, sibling) {
            if (level > 0) {
                const indent = "  ".repeat(level - 1);
                const l = node.children.length > 0 ? "┬" : "─";
                const b = sibling < node.parent.children.length - 1 ? "├" : "└";
                lines.push(`${indent}${b}─${l} ${node.tagName}${decoration(node)}`);
            }
            else {
                lines.push("(root)");
            }
            node.children.forEach((child, index) => writeNode(child, level + 1, index));
        }
        writeNode(dom.root, 0, 0);
        return lines;
    }
    getRuleDocumentation(ruleId, context) {
        const rules = this.config.getRules();
        if (rules.has(ruleId)) {
            const [, options] = rules.get(ruleId);
            const rule = this.instantiateRule(ruleId, options);
            return rule.documentation(context);
        }
        else {
            return null;
        }
    }
    processDirective(event, parser, allRules) {
        const rules = event.data
            .split(",")
            .map(name => name.trim())
            .map(name => allRules[name])
            .filter(rule => rule);
        switch (event.action) {
            case "enable":
                this.processEnableDirective(rules, parser);
                break;
            case "disable":
                this.processDisableDirective(rules, parser);
                break;
            case "disable-block":
                this.processDisableBlockDirective(rules, parser);
                break;
            case "disable-next":
                this.processDisableNextDirective(rules, parser);
                break;
            default:
                this.reportError(`Unknown directive "${event.action}"`, event.location);
                break;
        }
    }
    processEnableDirective(rules, parser) {
        for (const rule of rules) {
            rule.setEnabled(true);
            if (rule.getSeverity() === config_1.Severity.DISABLED) {
                rule.setServerity(config_1.Severity.ERROR);
            }
        }
        parser.on("tag:open", (event, data) => {
            for (const rule of rules) {
                data.target.enableRule(rule.name);
            }
        });
    }
    processDisableDirective(rules, parser) {
        for (const rule of rules) {
            rule.setEnabled(false);
        }
        parser.on("tag:open", (event, data) => {
            for (const rule of rules) {
                data.target.disableRule(rule.name);
            }
        });
    }
    processDisableBlockDirective(rules, parser) {
        let directiveBlock = null;
        for (const rule of rules) {
            rule.setEnabled(false);
        }
        const unregisterOpen = parser.on("tag:open", (event, data) => {
            if (directiveBlock === null) {
                directiveBlock = data.target.parent.unique;
            }
            for (const rule of rules) {
                data.target.disableRule(rule.name);
            }
        });
        const unregisterClose = parser.on("tag:close", (event, data) => {
            const lastNode = directiveBlock === null;
            const parentClosed = directiveBlock === data.previous.unique;
            if (lastNode || parentClosed) {
                unregisterClose();
                unregisterOpen();
                for (const rule of rules) {
                    rule.setEnabled(true);
                }
                return;
            }
        });
    }
    processDisableNextDirective(rules, parser) {
        for (const rule of rules) {
            rule.setEnabled(false);
        }
        const unregister = parser.on("tag:open", (event, data) => {
            for (const rule of rules) {
                data.target.disableRule(rule.name);
            }
        });
        parser.once("tag:open, tag:close, attr", () => {
            unregister();
            parser.defer(() => {
                for (const rule of rules) {
                    rule.setEnabled(true);
                }
            });
        });
    }
    loadRule(ruleId, severity, options, parser, report) {
        const rule = this.instantiateRule(ruleId, options);
        rule.name = rule.name || ruleId;
        rule.init(parser, report, severity);
        if (rule.setup) {
            rule.setup();
        }
        return rule;
    }
    instantiateRule(name, options) {
        if (this.availableRules[name]) {
            return new this.availableRules[name](options);
        }
        else {
            return this.requireRule(name, options) || this.missingRule(name);
        }
    }
    requireRule(name, options) {
        let Class;
        try {
            Class = require(`../rules/${name}`);
        }
        catch (e) {
            if (e.code === "MODULE_NOT_FOUND") {
                return null;
            }
            else {
                throw e;
            }
        }
        return new Class(options);
    }
    missingRule(name) {
        return new class extends rule_1.Rule {
            setup() {
                this.on("dom:load", () => {
                    this.report(null, `Definition for rule '${name}' was not found`);
                });
            }
        }({});
    }
    reportError(message, location) {
        this.report.addManual(location.filename, {
            ruleId: undefined,
            severity: config_1.Severity.ERROR,
            message,
            offset: location.offset,
            line: location.line,
            column: location.column,
            size: location.size || 0,
        });
    }
}
exports.Engine = Engine;
