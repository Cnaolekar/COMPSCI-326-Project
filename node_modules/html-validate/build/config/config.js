"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const deepmerge = require("deepmerge");
const fs = require("fs");
const path = require("path");
const meta_1 = require("../meta");
const default_1 = require("./default");
const severity_1 = require("./severity");
const recommended = require("./recommended");
const document = require("./document");
let rootDirCache = null;
class Config {
    static empty() {
        return new Config({
            extends: [],
            rules: {},
            plugins: [],
            transform: {},
        });
    }
    static fromObject(options) {
        return new Config(options);
    }
    static fromFile(filename) {
        switch (filename) {
            case "htmlvalidate:recommended":
                return Config.fromObject(recommended);
            case "htmlvalidate:document":
                return Config.fromObject(document);
        }
        const json = require(filename);
        for (const key of ["extends", "elements", "plugins"]) {
            if (!json[key])
                continue;
            json[key] = json[key].map((ref) => {
                return Config.expandRelative(ref, path.dirname(filename));
            });
        }
        return new Config(json);
    }
    static defaultConfig() {
        return new Config(default_1.default);
    }
    constructor(options) {
        this.config = {
            extends: [],
            plugins: [],
            rules: {},
            transform: {},
        };
        this.mergeInternal(options || {});
        this.metaTable = null;
        this.rootDir = this.findRootDir();
        for (const extend of this.config.extends) {
            const base = Config.fromFile(extend);
            this.config = base.mergeInternal(this.config);
        }
    }
    init() {
        this.plugins = this.loadPlugins(this.config.plugins || []);
        this.transformers = this.precompileTransformers(this.config.transform || {});
    }
    merge(rhs) {
        return new Config(this.mergeInternal(rhs.config));
    }
    getMetaTable() {
        if (this.metaTable) {
            return this.metaTable;
        }
        this.metaTable = new meta_1.MetaTable();
        const source = this.config.elements || ["html5"];
        const root = path.resolve(__dirname, "..", "..");
        for (const entry of source) {
            if (typeof entry !== "string") {
                this.metaTable.loadFromObject(entry);
                continue;
            }
            const filename = `${root}/elements/${entry}.json`;
            if (fs.existsSync(filename)) {
                this.metaTable.loadFromFile(filename);
                continue;
            }
            if (fs.existsSync(entry)) {
                this.metaTable.loadFromFile(entry);
                continue;
            }
            this.metaTable.loadFromObject(require(entry));
        }
        this.metaTable.init();
        return this.metaTable;
    }
    static expandRelative(src, currentPath) {
        if (src[0] === ".") {
            return path.normalize(`${currentPath}/${src}`);
        }
        return src;
    }
    mergeInternal(config) {
        this.config = deepmerge(this.config, config);
        return this.config;
    }
    get() {
        const config = Object.assign({}, this.config);
        if (config.elements) {
            config.elements = config.elements.map((cur) => cur.replace(this.rootDir, "<rootDir>"));
        }
        return config;
    }
    getRules() {
        const rules = new Map();
        for (const [ruleId, data] of Object.entries(this.config.rules || {})) {
            let options = data;
            if (!Array.isArray(options)) {
                options = [options, {}];
            }
            else if (options.length === 1) {
                options = [options[0], {}];
            }
            const severity = severity_1.parseSeverity(options[0]);
            rules.set(ruleId, [severity, options[1]]);
        }
        return rules;
    }
    getPlugins() {
        return this.plugins;
    }
    loadPlugins(plugins) {
        return plugins.map((name) => {
            return require(name);
        });
    }
    transform(filename) {
        const transformer = this.findTransformer(filename);
        if (transformer) {
            return transformer.fn(filename);
        }
        else {
            const data = fs.readFileSync(filename, { encoding: "utf8" });
            return [
                {
                    data,
                    filename,
                    line: 1,
                    column: 1,
                    originalData: data,
                },
            ];
        }
    }
    findTransformer(filename) {
        return this.transformers.find((entry) => entry.pattern.test(filename));
    }
    precompileTransformers(transform) {
        return Object.entries(transform).map(([pattern, module]) => {
            return {
                pattern: new RegExp(pattern),
                fn: require(module.replace("<rootDir>", this.rootDir)),
            };
        });
    }
    findRootDir() {
        if (rootDirCache !== null) {
            return rootDirCache;
        }
        let current = process.cwd();
        for (;;) {
            const search = path.join(current, "package.json");
            if (fs.existsSync(search)) {
                return (rootDirCache = current);
            }
            const child = current;
            current = path.dirname(current);
            if (current === child) {
                break;
            }
        }
        return (rootDirCache = process.cwd());
    }
}
exports.Config = Config;
